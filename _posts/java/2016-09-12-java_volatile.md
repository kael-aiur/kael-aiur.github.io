---
layout: post
comments: true
categories: java
title: java中volatile关键字 
tags: volatile,java,并发,多线程
grammar_cjkRuby: true
---

## 前言

昨天在读jdk的线程池实现的时候，发现线程池中使用了一个关键字`volatile`，这个关键字其实知道很久了，一直都不太理解，因为很多专家和书都强烈推荐不要使用这个关键字，所以一直都很迷惑这个关键字的用途，也不知道为什么要设计这个关键字，今天难得有点时间，决定把这个迷惑彻底解开。

## `volatile`到底有什么用

在java的定义中，`volatile`关键字是用来保证变量的改动在并发环境下的修改可见性的，官方文档给的解释是保证变量被读取时读到的时候变量最后一次被线程修改的值。

这里很容易让人误解，以为这个关键字能保证变量的线程安全性，这里我们用一段代码来测试一下:

```java
public class Main1 {
    public static volatile int count = 0;

    public static void main(String[] args) {

        for (int i = 0; i < 10000; i++) {
            new Thread(() -> {
                count++;
                
            }).start();
        }
        System.out.println(count);
    }
}
```

运行结果如下：

```
9972
```

是不是发现不太对？没错，这里实际上在并发环境下，即使用了`volatile`也并不是现成安全的，这是为什么呢？在百度上很多文章都是各种转载，很多转发的人可能并没有真正理解过文章说的内容，这点确实坑了不少人，包括我。

实际上，`volatile`关键字确实是在并发环境下使用的，但是它并不保证线程安全，它保证的是每次线程要读取他的值的时候，都是最后一次被修改的值，这个值可能是被其他线程修改的，也可以是被自己修改的。

要理解这句话是什么意思，我们需要先了解jvm的内存模型。

## jvm内存模型

![enter description here][1]

从内存模型中我们可以看到，java将内存划分为两大块，一块是线程共享区，也就是主内存，包含java堆和方法区，另一块是线程私有区，有虚拟机栈，本地方法栈和程序计数器。

线程共享区用来存放java运行时的数据，线程私有区是在每个线程私有的，在编译的时候已经决定了大小，java会在线程运行的时候，将一些变量复制到线程私有区中使用。

关于虚拟机内存模型不是本文的重点，我们只了解到这里即可。

## `volatile`的真正作用

现在我们已经知道了，在并发环境下，每个线程都会从主内存读取自己需要的信息并拷贝一份到自己的线程私有区，因此，在上面的测试程序中，如果我们没有加上`volatile`关键字，每个线程处理的其实是自己线程私有区内的变量，处理完成之后再把结果写回主内存，也就是线程共享区，在这个过程里，`count`变量的变化其实对其他线程是不可见的，因此会导致并发问题。

但是即使我们加上了`volatile`关键字，从前面的实验上看，依然会有并发的问题，这是为什么呢?

实际上，`volatile`的真正作用是，告诉虚拟机，在使用这个变量的时候，不要拷贝一份到线程私有区，使用引用的方式来使用这个变量，也就是说，需要读这个变量的时候，直接从主内存的地址读，而不是拷贝一份到自己的私有区，再读私有区的内容，要修改这个变量的时候，也直接修改主内存的变量，而不是修改本地拷贝，再写回主内存。

理解了`volatile`的真正作用，现在我们来看看为什么上面的程序依然存在并发问题。

假设我们有两个线程，分别叫线程1和线程2，由于CPU是随机执行线程的，并且每个线程只有特定的时间片，因此可能会出现如下的执行顺序：

1. 线程1读取count的值，此时count的值为0
2. 线程2读取count的值，此时count的值为0
3. 线程1修改count的值为count+1=0+1=1，这个值会直接写到主内存，此时count的值为1
4. 线程2修改count的值为count+1=0+1，这个值再次写到主内存，count的值为1

这个时候是不是发现，这个就是并发问题？没错，确实是这样，虽然线程不再写自己的私有区变量，而是直接写到主内存，仍然不能保证在count下一次被读取前先把值写回去，所以并发的问题依然存在。

因此，`volatile`不能用来解决并发操作的问题。

  [1]: https://raw.githubusercontent.com/kael-aiur/image-repo1/master/java_volatile/java_vm_mem.png "java_vm_mem.png"