---
layout: post
comments: true
categories: redis
title: redis内存占用估算
tags: redis,优化
grammar_cjkRuby: true
---

* content
{:toc}

## 前言

Redis作为目前最流行的高速缓存组件，几乎所有大型分布式系统都离不开它，在实际使用redis的过程中，我们很少精确的去估算业务服务占用redis的内存，而是直接使用，等到出现内存不足的时候才开始考虑扩容。

这种做法实际上是节约前期的设计和调研成本，转而耗费更大的更大的后期运维成本。

在Redis的几种部署模式中，只有cluster模式可以横向扩容，单机部署和哨兵模式的扩容都需要停机修改服务器的物理内存才能实现扩容，成本巨大。

因此对于无法预估缓存占用的服务强烈建议使用集群模式，当然本文为了让我们能够更精确的预估内存占用，本文我们将着重讨论Redis的内存占用估算方法。

> 本文中所有的内容基于Redis 6.2.9版本讨论，不过五种常见数据类型的存储结构在各个版本间差异不大，可以作为各个版本的内存占用估算参考依据。

## Redis的存储结构

Redis目前常用的共有5中数据类型，`String`,`Hash`,`List`,`Set`,`ZSet`。

还有一些不常用的数据类型：

|数据类型|引入版本|用途|
|----|----|----|
|HyperLogLog|2.8.9|用于估算集合基数|
|Streams|5.0|存储流数据，用于支持订阅发布|
|Geospatial|3.2|存储坐标信息|
|Bitmap|2.2.0|把string的key当成一个位向量使用，可以用于高效设置一个整数集合或者用于对象权限存储|

在本文我们只讨论5中常见数据类型的存储空间评估方法。

## Redis的存储结构

在讨论每种类型的数据结构在Redis中存储的方式之前，我们先看看Redis整体的存储逻辑结构是怎么样的，如下图：

![](/static/img/blog/redis/redis_memory_1.png)

最顶层的redisServer是一个抽象概念，可以理解为一个redis实例，只有在集群中才会有多个redisServer。
第二层是redisDB，是一个Redis实例中划分的逻辑区域（在cluster模式下不可用）,默认情况下是16个DB。
第三层是dict，一个字典表，是数据真正存储的结构
第四层是dictht，在一个dict里有两个dictht，一般情况下只用一个，第二个dictht是在rehash的时候使用
第五层是dictEntry，就是保存每一个键值对的对象，这里key是一个sds对象，value是一个redisObject对象。

由上图我们知道，Redis中存储一个键值对的原子对象是dictEntry，这个结构体的定义如下：

```c++
typedef struct dictEntry {
    void *key;
    union {
        void *val;
        uint64_t u64;
        int64_t s64;
        double d;
    } v;
    struct dictEntry *next;
} dictEntry;
```

包括一个key，一个代表value的共用体，还有一个指向下一个dictEntry的指针。

> 这里使用共用体表示value，是因为不同类型的value存储的方式不一样，但是无论哪种类型，value在dictEntry中最终存储都是占了8字节。

在dictEntry中，key和value存储的字符串值实际上是一个指针，对于key，一般是string，指向的是Redis定义的sds（simple dynamic string）对象，对于value，则是存储为redisObject这个结构体的对象，如下图：

![dictEntry存储结构](/static/img/blog/redis/redis_memory_2.png)

我们来看下reidsObject的定义：

```c++
typedef struct redisObject {
    unsigned type:4;
    unsigned encoding:4;
    unsigned lru:LRU_BITS; /* LRU time (relative to global lru_clock) or
                            * LFU data (least significant 8 bits frequency
                            * and most significant 16 bits access time). */
    int refcount;
    void *ptr;
} robj;
```

* type用于存储value的类型
* encoding用于存储value的编码方式，在redis中，五种常见类型的数据都是以sds的方式存储的，只是不同场景下的编码方式有差异，因此这里用encoding表示编码方式
* refcount是一个引用计数器，对于0-9999范围内的数字类型数据，会用内置的数值型对象代替redisObject和sds，这时对共享对象的计数器进行+1操作，有利于节省内存
* ptr是一个指针对象，指向真正存储value的sds对象

现在我们可以看一下sds的定义了,在redis中，定义了sdshdr5，sdshdr8，sdshdr16，sdshdr32，sdshdr64几个结构体，用于支持不同长度的字符串，其中sdshdr5比较特殊，只在key中使用，value最小使用sdshdr8。
通常情况下，redis需要尽量避免使用过长的key和value，因此最常用的是sdshdr8，这里我们只讨论value为sdshdr8的情况，但是key则需要讨论sdshdr5和sdshdr8的情况，下面是这两个结构体的定义：

```c++
struct __attribute__ ((__packed__)) sdshdr5 {
    unsigned char flags; /* 3 lsb of type, and 5 msb of string length */
    char buf[];
};

struct __attribute__ ((__packed__)) sdshdr8 {
    uint8_t len; /* used */
    uint8_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
```
sdshdr5中：
* flags是一个标志符，低3位用于表示类型，高5位用于表示buf的长度，最大可以表示长度为2^7-1=31的数组
* buf[]是实际存储值的数组

sdshdr8中：
* len表示当前存储的值长度
* alloc表示当前已经申请的内存长度，即buf最大能存储的长度，但是这里不包含终止符`\0`，因此一个sds实际的占用内存还需要加上一个终止符字节
* flags是标志位，表示当前数据的类型，虽然是一个char，实际上值用了3个位（3个位足够表示5种数据类型），高位的5个位都为0
* buf[]数组就是真正存储value的地方

> 对于sds的内存占用，计算的时候只需要alloc+1即可，因为alloc是已经申请的内存，实际上即使暂时不存储数据，内存也已经占用了，而加1是为了包含sds终止符的长度，Redis采用类似C的做法存储字符串，也就是以`\0`结尾，`\0`只作为字符串的定界符，alloc的长度不包含这个，因此需要加1。

到这里我们已经完整的看完redis中一个键值对的存储方式和实现了，现在可以给出一个计算公式来计算一个键值对的空间占用：

```
          dictEnrty                             （key的长度大于31时）sdshdr8                                                                         redisObject                                                                  value sds
  ┌───────────┼───────────┐           ┌───────────┬───────────┼──────────────┬──────────────────┐            ┌─────────────────┬──────────────────┬─────┴─────────┬──────────────────┬──────────┐          ┌───────────┬───────────┼─────────────────┬─────────────────┐
  |           |           |           |           |           |              |                  |            |                 |                  |               |                  |          |          |           |           |                 |                 |        
key指针    value指针    next指针       len        alloc       flags        buf.length          标志位\0    type占4个bit    encoding占4个bit      lru占24个bit    一个byte是8个bit      refcount    ptr指针       len        alloc       flags           buf.length         标志位\0
  |           |           |           |           |           |              |                  |            |                 |                  |               |                  |          |          |           |           |                 |                 |
  8     +     8     +     8     +     1     +     1     +     1     +   {key_alloc}      +      1     +     (4        +        4           +     24)      /       8         +        4     +    8     +    1     +     1     +     1     +     {value_alloc}     +     1
                                                              1     +   {key_alloc}      +      1
                                                              |              |                  |            |                                                                                                                                                         |
                                                               ──────────────┼──────────────────              ───────────────────────────────────────────────────────────────────────────────────────┬─────────────────────────────────────────────────────────────────            
                                                                （key的长度小于31时）sdshdr5                                                                       当value是数字类型并且小于2^64时，dictEntry直接存储数值，不需要这两个对象，空间占用为0
```
最终结论分四种情况：
|场景|公式（byte）|说明|
|----|----|----|
|key.length < 31，value为字符串|46 + `{key_alloc}` + `{value_alloc}`|key的最长长度是30|
|key.length < 31，value为数值|26 + `{key_alloc}`|value的范围是整数-2^63到2^64或者double类型|
|key.lenght >= 31，value为字符串|48 + `{key_alloc}` + `{value_alloc}`|key的最短长度是31|
|key.length >= 31, value为数值|28 + `{key_alloc}`|value的范围是整数-2^63到2^64或者double类型|

> 特别说明，你可能已经注意到，sdshdr5能表示的最大长度是31，但是我们使用key的长度最大智能到30，这是为什么呢？  
> 因为Redis采用Jemalloc内存分配器，每次都以8byte为单位进行分配，因此当我们使用的key长度达到30之后，加上标志位`\0`和`flags`正好达到32，此时如果继续增加key的长度，
> Jemalloc会再增加8个byte，达到40个byte，那sdshdr5就无法表示了，这种情况下redis会直接将key的存储改为sdshdr8，因此如果希望key使用sdshdr5保存，我们实际能使用的最大key长度是30，第31个byte留给了`\0`标志位。

那么问题来了，如何估算`{key_alloc}`和`{value_alloc}`？

`{key_alloc}`是每个key序列化之后存储的byte数组长度，由于Redis采用Jemalloc进行内存分配，因此并不是每次都按存储key的长度需要的内存分配的而是以8字节为单位进行分配，所以`{key_alloc}`的估算伪代码如下：

```
var length = key.length
if (length < 31){
    if (length <= (8 - 1 - 1)){                             // Jemalloc最低分配的一块内存为8byte，这里8byte分配给sdshdr5结构体，减去flags标志和'\0'标志位，剩余的空间即为可用于存储key的byte数组
        key_alloc = 6;                                      // 当key长度小于等于可用于存储key的byte数组长度时，直接存储在这个数组中，而这个数组的长度已经确定为6，因此key_alloc就是6
    }else{                                                  // 当key的长度大于6时，表示sdshdr5中用于存储key的byte数组空间不够，这种情况下Jemalloc会以8byte为单位继续申请内存
        key_alloc = [(length - 6) / 8] * 8 + 6              // length减去6是扣除6个可以存储到sdshdr5中的字节，剩余的需要重新申请内存，除以8并向上取整，可以得出需要申请多少个单位（8字节为一单位），然后乘以8得出一共多少字节，最后加6是加回原本扣除的6字节。
    }
} else {
    key_alloc = [(length - (8 - 1 - 1 - 1 - 1))/8] * 8 + 4  // 当length达到31以上时，key会使用sdshdr8存储，此时会申请8byte用于存储sdshdr8结构体，减去4个1，分别代表len，alloc，flags和'\0'标志位，剩下的内存即可用于存储key，扣除存到sdshdr8中剩余存储空间的长度后，剩下的Jemalloc会以8byte为单位继续申请内存，最后加4是加回扣除的4个1
}
```

现在我们已经知道如何估算`{key_alloc}`的值了，`{value_alloc}`是每个value序列化之后存储的长度，这就涉及到不同数据类型的编码算法了，我们针对每种类型进行分析。

## String

对于String类型的值，我们知道一共有三种编码算法：
* OBJ_ENCODING_INT: 适用于可以转换为数字并且范围在-2^63~2^64范围内的整型，或者双精度浮点数double的情况
* OBJ_ENCODING_EMBSTR: 适用于长度不超过44的字符串类型的value，为什么是44？这是因为这种编码方式是将redisObject和sdshdr8作为一块连续的内存申请的，除去两个结构体本身占用的内存16 + 3 + 1 = 20，而embstr会一次性申请64字节的内存，因此可以用于存储字符串的长度就是64 - 20 = 44
* OBJ_ENCODING_RAW: 适用于长度超过44的字符串类型

> 补充说明：在OBJ_ENCODING_EMBSTR编码方式中，Redis 3.2以前由于实现方式的差异，两个结构体本身占用的内存是16 + 8 + 1 = 25，而64 - 25 = 39，因此在Redis 3.2以前，这种编码适用于key的长度不超过39的字符串。

虽然OBJ_ENCODING_EMBSTR和OBJ_ENCODING_RAW的编码方式不同，但是差异主要在于查询性能，对内存占用没有差异，因此内存占用的算法也是一样的。

### value为数字

大多数情况下，我们的数字很少超过2^64，因此对于数字类型的情况，基本上可以认为redis会直接存储在dictEntry中，value占用空间为0，此时value使用的编码方式是OBJ_ENCODING_INT。

### value为字符串

value为字符串时，占用空间的计算伪代码如下：

```
var length = key.length
if (length <= 4){                           // value不会使用sdshdr5存储，最小使用sdshdr8，当length小于等于4时，value的结果可以直接存储在sdshdr8中扣除四个结构体变量后剩余的4字节中，不需要额外申请内存
    value_alloc = 4                         // sdshdr8中剩余的4个byte 
} else {
    value_alloc = [(length - 4)/8] * 8 + 4  // 扣除存到sdshdr8中的4个byte，剩余的需要继续申请以8byte为单位申请内存，因此除以8并向上取整，乘以8的到最终需要申请的byte长度，最后加4是加回原本扣除的4字节
}
```

## 工具

Redis提供了一个非常简单好用的网页工具，用于帮我们估算业务缓存对Redis的内存占用：

[Redis内存占用估算](http://www.redis.cn/redis_memory/)。