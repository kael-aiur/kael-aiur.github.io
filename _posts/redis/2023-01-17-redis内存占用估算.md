---
layout: post
comments: true
categories: redis
title: redis内存占用估算
tags: redis,优化
grammar_cjkRuby: true
---

* content
{:toc}

## 前言

Redis作为目前最流行的高速缓存组件，几乎所有大型分布式系统都离不开它，在实际使用redis的过程中，我们很少精确的去估算业务服务占用redis的内存，而是直接使用，等到出现内存不足的时候才开始考虑扩容。

这种做法实际上是节约前期的设计和调研成本，转而耗费更大的更大的后期运维成本。

在Redis的几种部署模式中，只有cluster模式可以横向扩容，单机部署和哨兵模式的扩容都需要停机修改服务器的物理内存才能实现扩容，成本巨大。

因此对于无法预估缓存占用的服务强烈建议使用集群模式，当然本文为了让我们能够更精确的预估内存占用，本文我们将着重讨论Redis的内存占用估算方法。

## Redis的存储结构

Redis目前常用的共有5中数据类型，`String`,`Hash`,`List`,`Set`,`ZSet`。

还有一些不常用的数据类型：

|数据类型|引入版本|用途|
|----|----|----|
|HyperLogLog|2.8.9|用于估算集合基数|
|Streams|5.0|存储流数据，用于支持订阅发布|
|Geospatial|3.2|存储坐标信息|
|Bitmap|2.2.0|把string的key当成一个位向量使用，可以用于高效设置一个整数集合或者用于对象权限存储|

在本文我们只讨论5中常见数据类型的存储空间评估方法。

## Redis的存储结构

在讨论每种类型的数据结构在Redis中存储的方式之前，我们先看看Redis整体的存储逻辑结构是怎么样的，如下图：

![](/static/img/blog/redis/redis_memory_1.png)

最顶层的redisServer是一个抽象概念，可以理解为一个redis实例，只有在集群中才会有多个redisServer。
第二层是redisDB，是一个Redis实例中划分的逻辑区域（在cluster模式下不可用）,默认情况下是16个DB。
第三层是dict，一个字典表，是数据真正存储的结构
第四层是dictht，在一个dict里有两个dictht，一般情况下只用一个，第二个dictht是在rehash的时候使用
第五层是dictEntry，就是保存每一个键值对的对象，这里key和value都是一个redisObject对象。



redisObject是redis中定义的一个结构体，源码如下：

```c++
struct __attribute__ ((__packed__)) sdshdr8 {
    uint8_t len;
    uint8_t alloc;
    unsigned char flags;
    char buf[];
};
```

在上面的定义中：
* len用于存储当前数据的长度
* alloc表示目前申请分配的内存大小，相当于实际占用的内存
* flags表示数据类型，即常见的5中数据类型
* buf[]数组就是存储的内容

到这里我们可以知道，redis在存储一个键值对时，并不是按key和value的实际大小存储的，实际占用的空间还包括sds中定义的一些字段，并且申请的内存大小一般情况下也比实际存储的大小要大一些。

## String

String类型大概是Redis中使用最广泛的类型了，在我们讨论如何估算String类型的存储空间之前，我们得先了解String类型在Redis中是如何存储的，在Redis中，String类型存储并不是简单的char数组，而是分两种情况存储：
1. 当字符串可以被解析为int类型时，
定义了一个sds(simple dynamic string)的类型

## 工具

Redis提供了一个非常简单好用的网页工具，用于帮我们估算业务缓存对Redis的内存占用：

[Redis内存占用估算](http://www.redis.cn/redis_memory/)。